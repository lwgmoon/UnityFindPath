# A星寻路算法实现

## 算法原理

A星（A*）算法是一种启发式搜索算法，广泛应用于游戏开发中的寻路系统。它结合了Dijkstra算法（保证找到最短路径）和最佳优先搜索（使用启发式函数提高效率）的优点。

### 核心概念

1. **评估函数**：f(n) = g(n) + h(n)
   - g(n)：从起点到当前节点n的实际代价
   - h(n)：从当前节点n到终点的估计代价（启发式函数）
   - f(n)：总估计代价

2. **开放列表与关闭列表**
   - 开放列表：待评估的节点
   - 关闭列表：已评估的节点

3. **启发式函数**
   - 曼哈顿距离：|x1 - x2| + |y1 - y2|（适用于四方向移动）
   - 欧几里得距离：√((x1 - x2)² + (y1 - y2)²)（适用于任意方向移动）

### 算法步骤

1. 将起点加入开放列表
2. 循环以下步骤直到找到路径或开放列表为空：
   - 从开放列表中选择f值最小的节点作为当前节点
   - 将当前节点从开放列表移到关闭列表
   - 如果当前节点是终点，回溯构建路径并返回
   - 对当前节点的每个相邻节点：
     - 如果相邻节点不可通行或已在关闭列表中，跳过
     - 计算从起点经过当前节点到相邻节点的代价（g值）
     - 如果相邻节点不在开放列表中或新路径更优，更新节点信息并加入开放列表

## 项目结构

本项目包含以下核心文件：

- **AStarPathfinding.cs**：A星算法的核心实现，包含Node类和AStarPathfinding类
- **GridVisualizer.cs**：网格可视化组件，用于在Unity场景中显示寻路网格和路径
- **PathfindingDemo.cs**：演示脚本，展示如何使用A星寻路系统

## 使用方法

### 基本用法

```csharp
// 创建一个10x10的网格
AStarPathfinding pathfinding = new AStarPathfinding(10, 10);

// 设置障碍物
List<Vector2Int> obstacles = new List<Vector2Int>
{
    new Vector2Int(2, 2),
    new Vector2Int(2, 3),
    new Vector2Int(2, 4)
};

// 重新创建网格，包含障碍物
pathfinding = new AStarPathfinding(10, 10, obstacles);

// 寻找从(0,0)到(9,9)的路径
List<Vector2Int> path = pathfinding.FindPath(0, 0, 9, 9);

// 处理路径
if (path.Count > 0)
{
    Debug.Log("找到路径！");
    foreach (var point in path)
    {
        Debug.Log($"路径点: ({point.x}, {point.y})");
    }
}
else
{
    Debug.Log("未找到路径！");
}
```

### 在Unity场景中使用

1. 创建一个空游戏对象，添加GridVisualizer组件
2. 创建一个立方体预制体作为节点可视化，设置为GridVisualizer的nodePrefab
3. 调整网格设置（宽度、高度、单元格大小等）
4. 运行场景，使用以下按键进行交互：
   - 按住S并点击设置起点
   - 按住E并点击设置终点
   - 按住空格并点击切换节点是否可通行
   - 按R重置网格

## 性能优化

对于大型网格，可以考虑以下优化：

1. 使用优先队列（如二叉堆）代替列表来存储开放列表，提高查找最小f值节点的效率
2. 实现网格分区，只处理与角色相关的区域
3. 预计算静态障碍物的影响，减少实时计算
4. 对于动态更新的场景，考虑增量更新而非完全重新计算

## 扩展功能

可以扩展当前实现以支持：

1. 不同地形的移动代价
2. 动态障碍物处理
3. 平滑路径生成
4. 多单位协同寻路
5. 分层寻路（适用于大型世界）